# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13cIUOwztgpFZr4zYlvAkKsU3W-TMLv3m
"""

# Commented out IPython magic to ensure Python compatibility.
# Install the necessary libraries
!pip install pandas sqlalchemy ipython-sql

# Connect to a local SQLite database file
# This will create a file named 'food_wastage.db'
# %load_ext sql
# %sql sqlite:///food_wastage.db

print("Libraries installed and database connected. You can now upload your CSV files using the file icon on the left sidebar.")

"""## Load csvs into dataframes

### Subtask:
Load the four CSV files into pandas DataFrames.

"""

import pandas as pd

receivers_df = pd.read_csv('/content/receivers_data.csv')
providers_df = pd.read_csv('/content/providers_data.csv')
food_listings_df = pd.read_csv('/content/food_listings_data.csv')
claims_df = pd.read_csv('/content/claims_data.csv')

print("Head of receivers_df:")
display(receivers_df.head())

print("\nHead of providers_df:")
display(providers_df.head())

print("\nHead of food_listings_df:")
display(food_listings_df.head())

print("\nHead of claims_df:")
display(claims_df.head())

dataframes = [receivers_df, providers_df, food_listings_df, claims_df]
dataframe_names = ['receivers_df', 'providers_df', 'food_listings_df', 'claims_df']

for df, name in zip(dataframes, dataframe_names):
  df.columns = df.columns.str.replace(' ', '_')
  print(f"Columns of {name} after cleaning:")
  print(df.columns)
  print("-" * 30)

# Convert 'Expiry_Date' column in food_listings_df to datetime objects
food_listings_df['Expiry_Date'] = pd.to_datetime(food_listings_df['Expiry_Date'])

print("Data cleaning complete.")

from sqlalchemy import create_engine

engine = create_engine('sqlite:///food_wastage.db')

receivers_df.to_sql('receivers', con=engine, if_exists='replace', index=False)
providers_df.to_sql('providers', con=engine, if_exists='replace', index=False)
food_listings_df.to_sql('food_listings', con=engine, if_exists='replace', index=False)
claims_df.to_sql('claims', con=engine, if_exists='replace', index=False)

print("DataFrames successfully loaded into the SQLite database as tables.")

"""## Load data into tables

### Subtask:
Load the data from each DataFrame into their respective tables in the SQLite database.

**Reasoning**:
Load the data from each DataFrame into their respective tables in the SQLite database using the 'append' mode.
"""

engine = create_engine('sqlite:///food_wastage.db')

receivers_df.to_sql('receivers', con=engine, if_exists='append', index=False)
providers_df.to_sql('providers', con=engine, if_exists='append', index=False)
food_listings_df.to_sql('food_listings', con=engine, if_exists='append', index=False)
claims_df.to_sql('claims', con=engine, if_exists='append', index=False)

print("Data from DataFrames successfully appended to the SQLite database tables.")

"""## Verify data loading

### Subtask:
Query the database to verify that the data has been loaded correctly into the tables.

"""

from sqlalchemy import create_engine
import pandas as pd

engine = create_engine('sqlite:///food_wastage.db')

query_receivers = "SELECT * FROM receivers LIMIT 5;"
query_providers = "SELECT * FROM providers LIMIT 5;"
query_food_listings = "SELECT * FROM food_listings LIMIT 5;"
query_claims = "SELECT * FROM claims LIMIT 5;"

df_receivers_query = pd.read_sql(query_receivers, engine)
df_providers_query = pd.read_sql(query_providers, engine)
df_food_listings_query = pd.read_sql(query_food_listings, engine)
df_claims_query = pd.read_sql(query_claims, engine)

print("First 5 rows of receivers table:")
display(df_receivers_query)

print("\nFirst 5 rows of providers table:")
display(df_providers_query)

print("\nFirst 5 rows of food_listings table:")
display(df_food_listings_query)

print("\nFirst 5 rows of claims table:")
display(df_claims_query)

!pip install streamlit

import sqlite3

conn = sqlite3.connect("food_wastage.db")
cursor = conn.cursor()
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
print(cursor.fetchall())

import sqlite3

# Connect to your database
conn = sqlite3.connect("food_wastage.db")
cursor = conn.cursor()

# List all tables
cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cursor.fetchall()
print("Tables in DB:", tables)

# Commented out IPython magic to ensure Python compatibility.
# %%sql
# SELECT Status,
#        (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM claims)) AS Percentage
# FROM claims
# GROUP BY Status;

!pip install pandas matplotlib sqlalchemy

import sqlite3
import pandas as pd

# Connect or create the database
conn = sqlite3.connect("food_wastage.db")

# Load CSVs into DataFrames
providers = pd.read_csv("providers_data.csv")
receivers = pd.read_csv("receivers_data.csv")
food_listings = pd.read_csv("food_listings_data.csv")
claims = pd.read_csv("claims_data.csv")

# Write DataFrames to SQL tables
providers.to_sql("providers", conn, if_exists="replace", index=False)
receivers.to_sql("receivers", conn, if_exists="replace", index=False)
food_listings.to_sql("food_listings", conn, if_exists="replace", index=False)
claims.to_sql("claims", conn, if_exists="replace", index=False)

conn.commit()
conn.close()

conn = sqlite3.connect("food_wastage.db")
print(pd.read_sql_query("SELECT name FROM sqlite_master WHERE type='table';", conn))
conn.close()

query = """
SELECT Status,
       COUNT(*) * 100.0 / (SELECT COUNT(*) FROM claims) AS Percentage
FROM claims
GROUP BY Status;
"""
conn = sqlite3.connect("food_wastage.db")
df = pd.read_sql_query(query, conn)
print(df)
conn.close()

query = """
SELECT Status,
       COUNT(*) * 100.0 / (SELECT COUNT(*) FROM claims) AS Percentage
FROM claims
GROUP BY Status;
"""
import pandas as pd
import sqlite3

conn = sqlite3.connect("food_wastage.db")
df = pd.read_sql_query(query, conn)
conn.close()

df

df.to_csv("query1_output.csv", index=False)

# Example: Add a new food listing
conn = sqlite3.connect("food_wastage.db")
conn.execute("""
INSERT INTO food_listings (Food_ID, Food_Name, Quantity, Expiry_Date, Provider_ID, Provider_Type, Location, Food_Type, Meal_Type)
VALUES (101, 'Bread', 50, '2025-08-20', 1, 'Restaurant', 'Mumbai', 'Vegetarian', 'Breakfast')
""")
conn.commit()
conn.close()

import sqlite3
import pandas as pd

# Connect to the database
conn = sqlite3.connect("food_wastage.db")

query1 = """
SELECT city, COUNT(*) AS provider_count
FROM providers
GROUP BY city;
"""
df1 = pd.read_sql_query(query1, conn)

# Close the connection after use
conn.close()

df1

import sqlite3
import pandas as pd

# Connect to the database
conn = sqlite3.connect("food_wastage.db")

query2 = """
SELECT type, COUNT(*) AS food_count
FROM providers
GROUP BY type;
"""
df2 = pd.read_sql_query(query2, conn)

# Close the connection after use
conn.close()

df2

import sqlite3
import pandas as pd

# Connect to SQLite DB
conn = sqlite3.connect("food_wastage.db")

# Dictionary of queries
queries = {
    "query3_contact_providers_city": """
        SELECT Name, Contact
        FROM providers
        WHERE City = 'Mumbai';
    """,
    "query4_receivers_most_claims": """
        SELECT r.Name, COUNT(c.Claim_ID) AS claims_count
        FROM receivers r
        JOIN claims c ON r.Receiver_ID = c.Receiver_ID
        GROUP BY r.Name
        ORDER BY claims_count DESC;
    """,
    "query5_total_food_quantity": """
        SELECT SUM(Quantity) AS total_quantity
        FROM food_listings;
    """,
    "query6_city_most_listings": """
        SELECT Location, COUNT(*) AS listing_count
        FROM food_listings
        GROUP BY Location
        ORDER BY listing_count DESC
        LIMIT 1;
    """,
    "query7_common_food_types": """
        SELECT Food_Type, COUNT(*) AS type_count
        FROM food_listings
        GROUP BY Food_Type
        ORDER BY type_count DESC;
    """,
    "query8_claims_per_food_item": """
        SELECT f.Food_Name, COUNT(c.Claim_ID) AS claims_count
        FROM food_listings f
        JOIN claims c ON f.Food_ID = c.Food_ID
        GROUP BY f.Food_Name
        ORDER BY claims_count DESC;
    """,
    "query9_provider_most_successful_claims": """
        SELECT p.Name, COUNT(c.Claim_ID) AS completed_claims
        FROM providers p
        JOIN food_listings f ON p.Provider_ID = f.Provider_ID
        JOIN claims c ON f.Food_ID = c.Food_ID
        WHERE c.Status = 'Completed'
        GROUP BY p.Name
        ORDER BY completed_claims DESC
        LIMIT 1;
    """,
    "query10_percentage_claims_status": """
        SELECT Status,
               COUNT(*) * 100.0 / (SELECT COUNT(*) FROM claims) AS percentage
        FROM claims
        GROUP BY Status;
    """,
    "query11_avg_quantity_per_receiver": """
        SELECT r.Name, AVG(f.Quantity) AS avg_quantity
        FROM receivers r
        JOIN claims c ON r.Receiver_ID = c.Receiver_ID
        JOIN food_listings f ON c.Food_ID = f.Food_ID
        GROUP BY r.Name
        ORDER BY avg_quantity DESC;
    """,
    "query12_most_claimed_meal_type": """
        SELECT Meal_Type, COUNT(*) AS claims_count
        FROM food_listings f
        JOIN claims c ON f.Food_ID = c.Food_ID
        GROUP BY Meal_Type
        ORDER BY claims_count DESC
        LIMIT 1;
    """,
    "query13_total_quantity_per_provider": """
        SELECT p.Name, SUM(f.Quantity) AS total_donated
        FROM providers p
        JOIN food_listings f ON p.Provider_ID = f.Provider_ID
        GROUP BY p.Name
        ORDER BY total_donated DESC;
    """,
    "query14_top5_locations_completed_claims": """
        SELECT f.Location, COUNT(c.Claim_ID) AS completed_claims
        FROM food_listings f
        JOIN claims c ON f.Food_ID = c.Food_ID
        WHERE c.Status = 'Completed'
        GROUP BY f.Location
        ORDER BY completed_claims DESC
        LIMIT 5;
    """,
    "query15_providers_expiring_soon": """
        SELECT p.Name, f.Food_Name, f.Expiry_Date
        FROM providers p
        JOIN food_listings f ON p.Provider_ID = f.Provider_ID
        WHERE DATE(f.Expiry_Date) <= DATE('now', '+7 day')
        ORDER BY f.Expiry_Date ASC;
    """
}

# Loop through queries, run them, and save results
for name, sql in queries.items():
    df = pd.read_sql_query(sql, conn)
    df.to_csv(f"{name}.csv", index=False)
    print(f"{name} - {len(df)} rows saved to {name}.csv")

# Close the connection
conn.close()

import matplotlib.pyplot as plt
import pandas as pd

# Assuming df1 containing provider counts by city is available in the environment
# If not, you would need to regenerate it from the database query.

# Plot top 10 cities
df1.nlargest(10, "provider_count").plot(
    x="City",
    y="provider_count",
    kind="bar",
    title="Top 10 Cities by Number of Providers",
    figsize=(10,5)
)
plt.show()

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# Connect to the database
conn = sqlite3.connect("food_wastage.db")

# Query to get provider counts by city
query1 = """
SELECT city, COUNT(*) AS provider_count
FROM providers
GROUP BY city;
"""
df1 = pd.read_sql_query(query1, conn)

# Close the connection
conn.close()

# Plot top 10 cities by provider count
df1.nlargest(10, "provider_count").plot(
    x="City",
    y="provider_count",
    kind="bar",
    title="Top 10 Cities by Number of Providers",
    figsize=(10,5)
)
plt.xlabel("City")
plt.ylabel("Number of Providers")
plt.show()

import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# Connect to DB
conn = sqlite3.connect("food_wastage.db")

# Dictionary of queries with a title & chart type
queries = {
    "query1": {
        "sql": """
            SELECT City, COUNT(*) AS provider_count
            FROM providers
            GROUP BY City;
        """,
        "title": "Top 10 Cities by Number of Providers",
        "chart": "bar",
        "x": "City",
        "y": "provider_count",
        "top": 10
    },
    "query2": {
        "sql": """
            SELECT Type, COUNT(*) AS food_count
            FROM providers
            GROUP BY Type
            ORDER BY food_count DESC;
        """,
        "title": "Food Provider Type Contributions",
        "chart": "bar",
        "x": "Type",
        "y": "food_count"
    },
    "query7": {
        "sql": """
            SELECT Food_Type, COUNT(*) AS type_count
            FROM food_listings
            GROUP BY Food_Type
            ORDER BY type_count DESC;
        """,
        "title": "Most Common Food Types",
        "chart": "pie",
        "x": "Food_Type",
        "y": "type_count"
    },
    "query10": {
        "sql": """
            SELECT Status,
                   COUNT(*) * 100.0 / (SELECT COUNT(*) FROM claims) AS percentage
            FROM claims
            GROUP BY Status;
        """,
        "title": "Percentage of Claims by Status",
        "chart": "bar",
        "x": "Status",
        "y": "percentage"
    },
    "query12": {
        "sql": """
            SELECT Meal_Type, COUNT(*) AS claims_count
            FROM food_listings f
            JOIN claims c ON f.Food_ID = c.Food_ID
            GROUP BY Meal_Type
            ORDER BY claims_count DESC;
        """,
        "title": "Most Claimed Meal Type",
        "chart": "bar",
        "x": "Meal_Type",
        "y": "claims_count"
    },
    "query14": {
        "sql": """
            SELECT f.Location, COUNT(c.Claim_ID) AS completed_claims
            FROM food_listings f
            JOIN claims c ON f.Food_ID = c.Food_ID
            WHERE c.Status = 'Completed'
            GROUP BY f.Location
            ORDER BY completed_claims DESC
            LIMIT 5;
        """,
        "title": "Top 5 Locations by Completed Claims",
        "chart": "bar",
        "x": "Location",
        "y": "completed_claims"
    }
}

# Function to plot based on type
def plot_chart(df, title, chart, x, y, top=None):
    plt.figure(figsize=(8,5))
    if top:
        df = df.nlargest(top, y)
    if chart == "bar":
        plt.bar(df[x], df[y], color='skyblue')
        plt.xticks(rotation=45)
        plt.xlabel(x)
        plt.ylabel(y)
    elif chart == "pie":
        plt.pie(df[y], labels=df[x], autopct='%1.1f%%', startangle=90)
    plt.title(title)
    plt.tight_layout()
    plt.show()

# Loop through queries and plot
for qname, qdata in queries.items():
    df = pd.read_sql_query(qdata["sql"], conn)
    print(f"--- {qdata['title']} ---")
    print(df.head(10))
    plot_chart(df, qdata["title"], qdata["chart"], qdata["x"], qdata["y"], qdata.get("top"))

conn.close()

import streamlit as st
import sqlite3
import pandas as pd
import matplotlib.pyplot as plt

# Connect to DB
def run_query(query):
    conn = sqlite3.connect("food_wastage.db")
    df = pd.read_sql_query(query, conn)
    conn.close()
    return df

st.title("Local Food Wastage Management System Dashboard")

# Example: Query 1 - Providers per City
st.subheader("Top Cities by Number of Providers")
df1 = run_query("""
    SELECT City, COUNT(*) AS provider_count
    FROM providers
    GROUP BY City
    ORDER BY provider_count DESC
    LIMIT 10;
""")
st.dataframe(df1)

fig, ax = plt.subplots()
df1.plot(kind="bar", x="City", y="provider_count", ax=ax, color='skyblue')
plt.xticks(rotation=45)
st.pyplot(fig)

city = st.selectbox("Select City", df1["City"].unique())
df_filtered = df1[df1["City"] == city]
st.write(df_filtered)

!streamlit run app.py

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import sqlite3
# import pandas as pd
# import matplotlib.pyplot as plt
# 
# # Function to run a query
# def run_query(query):
#     conn = sqlite3.connect("food_wastage.db")
#     df = pd.read_sql_query(query, conn)
#     conn.close()
#     return df
# 
# st.title("Local Food Wastage Management Dashboard")
# 
# # Example query
# query1 = """
# SELECT City, COUNT(*) AS provider_count
# FROM providers
# GROUP BY City
# ORDER BY provider_count DESC
# LIMIT 10;
# """
# df1 = run_query(query1)
# st.subheader("Top 10 Cities by Number of Providers")
# st.dataframe(df1)
# 
# fig, ax = plt.subplots()
# df1.plot(kind="bar", x="City", y="provider_count", ax=ax, color='skyblue')
# plt.xticks(rotation=45)
# st.pyplot(fig)
#

!streamlit run app.py & npx localtunnel --port 8501

!streamlit run app.py & npx localtunnel --port 8501

